#!/usr/bin/env python3
# Freshen - finds and installs updates for GoboLinux systems.
# Copyright (C) 2007-2008 Michael Homer <=mwh>
# Copyright (C) 2024 Sage I. Hendricks <sage.message@email.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import string
import os
import os.path
import sys
import pickle
import time

from GetAvailable      import GetAvailable
from GuessLatest       import GuessLatest
from CheckDependencies import *
from PythonUtils       import *
from TTYUtils          import *

import Freshen
import Freshen.ArgParser as argparser


def getTypeAbbr(type):
    try:
        return getTypeAbbr.dict[type]
    except:
        getTypeAbbr.dict= {
        'recipe': Screen.colours['green']+'R'+Screen.colours['normal'],
        'official_package': (Screen.colours['brown'] + 'P'
                             + Screen.colours['normal']),
        'installed': 'I',
        'alien': Screen.colours['blue'] + 'A' + Screen.colours['normal'],
        None: '?'}
        return getTypeAbbr.dict[type]


def puts(string):
    sys.stdout.write(string)
    sys.stdout.write('\n')


class FreshenUI:
    goboPrograms = getGoboVariable('goboPrograms')
    _parse_var_definitions = {}
    corePrograms = ['Glibc', 'Udev', 'Shadow', 'Linux']

    def __init__(self):
        self.args = argparser.FreshenArgParser(self)
        self.limit = self.args.limit
        self.initTime = time.time()

    def error(self, message):
        Log_Error(message, 'Freshen')

    def log(self, message):
        Log_Normal(message, 'Freshen')

    def updates(self, examineSet, onExamine=None, last=False):
        if self.args.skipCore:
            self.args.skipSet = self.args.skipSet.union(self.corePrograms)
            if len(examineSet) < 20:
                self.args.skipSet = self.args.skipSet.difference(examineSet)
        req = Freshen.Request(mode=self.args.mode,
                              examineSet=examineSet,
                              skipSet=self.args.skipSet,
                              noCache=self.args.noCache,
                              forceCache=self.args.forceCache,
                              types=tuple(self.args.types),
                              noRevisions=self.args.noRevisions,
                              onExamine=onExamine,
                              last=last,
                              includeFlagChanges=self.args.includeFlagChanges)
        return req

    def showUpdates(self, updates=None):
        systemUpgrades = {'Scripts': None, 'Compile': None, 'Freshen': None}
        typeCount = {
            'recipe': 0,
            'official_package': 0,
            '_binary_recipe': 0,
            'total': 0,
            'alien': 0}
        examineSet = self.args.examineSet
        types = tuple(self.args.types)
        coreWarning = []
        if not examineSet:
            examineSet = frozenset(prog for prog in
                Freshen.installedPrograms() if
                Freshen.updateAvailable(prog, types, self.args.noRevisions))
        pb = ProgressBar(len(examineSet) + 1, self.limit, True)
        try:
            if updates is None:
                updates = self.updates(examineSet, onExamine=pb.inc)
            for update in updates:
                # Only output heading the first time, if there are any.
                if typeCount['total']==0:
                    puts("[  ] Program%sInstalled" %
                            (' ' * (Screen.width - 21)))
                # Keep track of how many of each type and in total there are
                typeCount[update.type] += 1
                typeCount['total'] += 1

                # Remember if there are updates to system tools
                if update.program in systemUpgrades:
                    systemUpgrades[update.program] = update.type
                if update.program in self.corePrograms:
                    coreWarning.append(update.program)
                if (update.type == 'recipe' and
                    Freshen.latestInstalled(update.program)
                    and os.path.exists(self.goboPrograms + '/'
                                        + update.program +
                                        '/Current/Resources/UseFlags')):
                    try:
                        currentFlags = set(open(
                                                self.goboPrograms +
                                                '/' + update.program +
                                                '/Current/Resources/UseFlags')
                                            .readline().split())
                    except:
                        Log_Error('Resources/UseFlags data file for '
                                    'installed %s exists but is not '
                                    'readable.' % (update.program), 'Freshen')
                else:
                    currentFlags = set()

                self.outProg(update, typeCount, currentFlags)
                pb.inc2()
                if typeCount['total'] == self.limit:
                    break
        except Freshen.CacheWarning:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            Log_Error(str(exc_obj), 'Freshen')
        finally:
            pb.clear()
            typeCount['time'] = time.time() - self.initTime
            puts("%(recipe)i recipes, %(_binary_recipe)i binary recipes, "
                    "%(official_package)i packages, %(total)i total "
                    "in %(time).2f seconds" % typeCount)
            for prog in ('Scripts', 'Compile', 'Freshen'):
                if systemUpgrades[prog]:
                    if 'recipe' == systemUpgrades[prog]:
                        cmd = 'Compile'
                    else:
                        cmd = 'InstallPackage'
                    Log_Error("An upgrade to %s is available. It is strongly "
                                "recommended that you upgrade immediately "
                                "with `%s %s`."%(prog, cmd, prog), 'Freshen')
            if coreWarning:
                Log_Error('Warning: this list contains updates to core '
                          'programs. It is recommended that you do not '
                          'upgrade these as part of a bulk upgrade; see '
                          'Freshen --help core for details. Included core '
                          'programs: ' + ', '.join(coreWarning) , 'Freshen')

    def promptInstall(self):
        examineSet = self.args.examineSet
        types = tuple(self.args.types)
        if not examineSet:
            examineSet = frozenset(prog for prog in
                Freshen.installedPrograms() if
                Freshen.updateAvailable(prog, types, self.args.noRevisions))
        updates = self.updates(examineSet)
        self.showUpdates(updates)
        Log_Normal("Do you want to install these updates? [y/N]", 'Freshen')
        r = sys.stdin.readline().strip()
        if 'y' == r:
            self.installUpdates(updates)

    def shell(self):
        examineSet = self.args.examineSet
        types = tuple(self.args.types)
        if not examineSet:
            examineSet = frozenset(prog for prog in
                Freshen.installedPrograms() if
                Freshen.updateAvailable(prog, types, self.args.noRevisions))
        request = self.updates(examineSet)
        while True:
            sys.stderr.write('>>> ')
            sys.stderr.flush()
            cmd = sys.stdin.readline()
            if not cmd or 'exit' == cmd:
                break
            cmd = cmd.strip()
            if 'list' == cmd:
                self.showUpdates(request)
                continue
            elif 'install' == cmd:
                self.installUpdates(updates)
            elif 'show examineset' == cmd:
                for p in examineSet:
                    sys.stdout.write(p + '\n')
                continue
            elif cmd.startswith('examine '):
                examineSet = frozenset(cmd.split()[1:])
            elif cmd.startswith('mode '):
                self.args.mode = cmd.split()[1]
            elif cmd.startswith('revisions '):
                self.args.noRevisions = cmd.split()[1] == 'off' and 1 or 0
            elif 'skipcore' == cmd:
                self.args.skipSet = self.args.skipSet.union(self.corePrograms)
            elif cmd.startswith('flagchanges '):
                self.args.includeFlagChanges = (cmd.split()[1] == 'on'
                                                and 1 or 0)
            elif cmd.startswith('limit '):
                self.args.limit = int(cmd.split()[1])
            elif cmd.startswith('types '):
                self.args.types = cmd.split()[1:]
            elif cmd.startswith('skip '):
                self.args.skipSet = frozenset(cmd.split()[1:])
            elif 'cache on' == cmd:
                self.args.noCache = False
                self.args.forceCache = False
            elif 'cache off' == cmd:
                self.args.noCache = True
                self.args.forceCache = False
            elif 'cache force' == cmd:
                self.args.forceCache = True
            elif 'reset' == cmd:
                self.args = FreshenArgParser(self)
                examineSet = self.args.examineSet
                types = tuple(self.args.types)
                if not examineSet:
                    examineSet = frozenset(prog for prog in
                        Freshen.installedPrograms() if
                        Freshen.updateAvailable(prog, types,
                            self.args.noRevisions))
            else:
                sys.stderr.write('Unknown command ' + cmd + '\n')
            request = self.updates(examineSet)

    def outFlag(self, flag, signal, currentFlags, currentlyEnabledColour,
                currentlyDisabledColour):
        outs = None
        if not currentFlags or flag in currentFlags:
            outs = [currentlyEnabledColour]
        else:
            outs = [currentlyDisabledColour]
        outs.append(signal)
        outs.append(flag)
        outs.append(' ')
        return ''.join(outs)

    def outProg(self, update, typeCount=None, currentFlags=set()):
        (program, version, revision, type, url, intBy, enabledFlags,
            disabledFlags, activeFlags) = update.tuple9()
        ver = Join_Version_Revision(version, revision)
        # Initialise default values (uninstalled program)
        insVer = "None"
        pcol = Screen.colours['darkgreybg']

        insVer = str(Freshen.latestInstalled(program))
        if insVer != 'None':
            # Alternate colouring by row for easier reading
            if typeCount and typeCount['total'] % 2 == 0:
                pcol = Screen.colours['blue']
            else:
                pcol = Screen.colours['cyan']

        typeAbbr = getTypeAbbr(type)

        # Flag binary recipes.
        if version.endswith('_bin') or program.endswith('-Bin'):
            typeAbbr = (Screen.colours['red'] + 'B' +
                        Screen.colours['normal'] + typeAbbr)
            if typeCount:
                typeCount['_binary_recipe'] += 1
        else:
            typeAbbr = ' ' + typeAbbr

        if intBy and activeFlags:
            intBy += ': +' + ', +'.join(activeFlags)
        # Display which program has this as a dependency if it isn't
        # already installed.
        introducedByString = '(' + intBy + ')' if insVer == 'None' else ''

        # Perform output. Flags are wrapped vertically when they don't
        # fit on one line.
        # The physical length of output must be tracked, which is
        # not the same as the string length because of colour escapes.
        maxlen = Screen.width - 10
        outs = []
        outs.append("[%s] %s%s %s %s " % (typeAbbr, pcol, program, ver,
                                            introducedByString))
        # outlen will be updated, minlen is used to pad wrapped text so
        # that it lines up.
        outlen = len(program) + len(ver) + len(introducedByString) + 8
        minlen = outlen
        # Whether the installed version has been output or not.
        insverout = False
        outs.append(Screen.colours['normal'])
        for flags, sig, enCol, disCol in (
                (enabledFlags, '+', Screen.colours['green'],
                    Screen.colours['brightgreen']),
                (disabledFlags, '-', Screen.colours['red'],
                    Screen.colours['blue']),
            ):
            for flag in flags:
                if flag.startswith('*'):
                    continue
                # Do we need to wrap yet?
                if outlen + len(flag) + 2 >= maxlen:
                    # If this is the first line, pad and output the version.
                    if not insverout:
                        insverout = True
                        outs.append(pcol)
                        outs.append(' ' * (Screen.width - outlen -
                                            len(insVer)))
                        outs.append(insVer + Screen.colours['normal'])
                    # Initialise the padding for the next line to
                    # vertically line up with the first flag.
                    outs.append('\n')
                    outs.append(' ' * minlen)
                    outlen = minlen
                # Two characters for the space and the [+-].
                outlen += len(flag) + 2
                outs.append(self.outFlag(flag, sig, currentFlags, enCol,
                                         disCol))

        # If this is the first line of this program, print the version.
        if not insverout:
            outs.append(pcol)
            outs.append(' ' * (Screen.width-outlen-len(insVer)))
            outs.append(insVer)
        puts(''.join(outs) + Screen.colours['normal'])

    def parse_var(self, string, **variableDefinitions):
        """Parse the value of a shell variable out of a file (recipe)

        Perform variable substitutions on the value
        """
        from string import Template
        if not self._parse_var_definitions:
            self._parse_var_definitions = {
                'goboPrograms': getGoboVariable('goboPrograms'),
                'goboShared': getGoboVariable('goboShared'),
                'goboSettings': getGoboVariable('goboSettings'),
                'goboLinks': getGoboVariable('goboLinks'),
            }
        if not variableDefinitions:
            variableDefinitions = {}
        variableDefinitions.update(self._parse_var_definitions)
        for variable in variableDefinitions:
            t = Template(variableDefinitions[variable])
            variableDefinitions[variable] = \
                t.safe_substitute(variableDefinitions)
        t = Template(string.split('=', 2)[1])
        return t.safe_substitute(variableDefinitions)

    def installUpdates(self, updates=None):
        i = 0
        postMessages = []
        programs = set()
        error = None
        ulist = []
        last = ('missing' == self.args.mode and not self.args.examineSet)
        types = tuple(self.args.types)
        examineSet = self.args.examineSet
        if not examineSet:
            examineSet = frozenset(prog for prog in
                Freshen.installedPrograms() if
                Freshen.updateAvailable(prog, types, self.args.noRevisions))
        try:
            if updates is None:
                updates = self.updates(examineSet, last=last)
            if not updates.updateCount:
                Log_Error('Warning: blind upgrading without review may '
                          'damage your system if core\npackages are included.'
                          ' It is strongly recommended that you use the \n'
                          'Freshen/Freshen -i double described in --help, '
                          'and upgrade these core\npackages individually '
                          'only if you are sure that you want to. See\n'
                          'Freshen --help core for more details.',
                          'Freshen')
            for u in updates:
                program, version, revision = u.program, u.version, u.revision
                i += 1
                programs.add(program)
                ver = Join_Version_Revision(version, revision)
                msg = "Installing update %i: %s %s" % (i, program, ver)
                # If the list was loaded from cache and is complete
                # (meaning the standard review-then-install method
                # was used), we know how many there are and can give
                # a better message.
                if updates.updateCount:
                    if not self.limit or self.limit > updates.updateCount:
                        self.limit = updates.updateCount
                    msg = "Installing update %i/%i: %s %s" % \
                            (i, self.limit, program, ver)
                sys.stderr.write("\033]2;%s\007" % (msg))
                Log_Normal(msg, 'Freshen')
                self.outProg(u)
                Freshen.installUpdate(u, symlink=self.args.symlink)
                ulist.append(u)
                rec = None
                if u.type != 'alien':
                    rec = (os.popen('GetRecipe %s %s' % (program, ver))
                             .readline().strip() + '/Recipe')
                if rec and os.path.exists(rec):
                    file = open(rec, 'r')
                    for line in file:
                        if line.startswith('post_install_message='):
                            postMessages.append((program,
                                self.parse_var(line,
                                         target='$goboPrograms/%s/%s' %
                                                (program, version))))
                            break
                    file.close()
                if i == self.limit:
                    break
        except Freshen.InstallationError:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            Log_Error("There was an error installing %s.\n"
                      "The update process will terminate.\n"
                      "Please review the errors above for details about"
                      " the problem." % (exc_obj.program))
            error = exc_obj
        except Freshen.CacheWarning:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            Log_Error(str(exc_obj), 'Freshen')
        finally:
            with_settings = []
            # Note that zero is the true exit state, so invert the test.
            for upd in ulist:
                if not os.system("UpdateSettings -c " + upd.program):
                    os.system("UpdateSettings -a " + upd.program)
                    if not os.system("UpdateSettings -c " + upd.program):
                        with_settings.append(upd.program)
            if with_settings:
                Log_Normal("Some programs need settings merged manually using"
                           "`UpdateSettings foo`: %s"
                           % (', '.join(with_settings)))
            if postMessages:
                Log_Normal("Some of the installed programs requested "
                            "post-install messages be displayed:")
                for program, message in postMessages:
                    puts("%s: %s" % (program, message))
            Freshen.clearCache()
        if error:
            Log_Error("Because there was an error in installation, not "
                        "all of your updates may have been installed. "
                        "You should review the error messages above for "
                        "details.")
            exit(1)

    def showVersion(self):
        puts("""
Freshen %(major)i.%(minor)i.%(revision)i%(prerelease)s
(C) 2007-2010 Michael Homer <michael@gobolinux.org>
(C) 2024 Sage I. Hendricks <sage.message@email.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
""" % (Freshen.version))

    def showHelp(self):
        if len(sys.argv) > 2 and 'core' in sys.argv:
            return self.showHelpCore()
        puts("""
Checks for updated GoboLinux recipes and packages.

Usage: Freshen <mode> [<opts>] [<list>]

Modes:
(default)
    Display list of updates.
--help
    This help text.
--install, -i
    Install <list> without upgrading any dependencies (equivalent to -U -s).
    When <list> is empty, install the updates produced by the last run of
    Freshen, to allow a simple review/install process.
--thorough
    Include deep updates to revisions and up-to-date dependencies.
--unordered
    Don't order updates or resolve dependencies.
-U
    Install updates.
--version
    Display version and copyright information.

Options:
--exclude, -x <xlist>
    Exclude <xlist> from updating. Does not exclude other programs depending
    on <xlist>.
--force-cache, -c
    Force using cached updates data, rather than recalculating them.
--include-core
    Do include updates to core programs (default).
--limit, -l <n>
    Only include the first <n> updates.
--prompt-install, -m
    Calculate and display the available updates, then prompt for review and
    approval to install them.
--no-cache, -C
    Force regenerating updates data, rather than reading from cache.
--no-colour
    Remove colours from output, suitable for piping through grep.
--no-revisions
    Do not include revision-only updates [default].
--shallow, -s
    Only include <list> and necessary dependencies.
--skip-core
    Do not include updates to core programs.
--with-revisions
    Do include revision-only updates.

Update type options:
--contrib
    Include contrib packages in update set.
--package, -p
    Include packages in update set.
--recipe, -r
    Include recipes in update set.
The order of these options sets the order of preference for each type.
If none are specified, the same as -p -r.

Notes:
Run with no arguments, Freshen outputs a list of updates in the form:
[%(red)sB%(green)sR%(normal)s] Foo 2.0                                   """
"""                              1.0
The mnemonics mean:
%(green)sR%(normal)s Recipe will be used              """
"""%(darkgreybg)sNew program%(normal)s
%(brown)sP%(normal)s Package will be used             """
"""Other colours are for readability only
%(red)sB%(normal)s Binary recipe

If <list> is provided, Freshen examines only the programs in it and their
dependencies. If <list> is not provided, Freshen will examine all installed
programs.

Examples:
Freshen -x LibFoo LibBar -U Baz Quux

Review/install pair:
    Freshen HTTPD PHP
    Freshen -i
""" % Screen.colours)

    def showHelpCore(self):
        puts("""
Upgrading certain core system programs can be dangerous if you are
unaware of it. Freshen may include these programs in its update list
when run in system upgrade mode or as dependencies with `Freshen -U <list>`.

It is recommended that you always review the list of programs to be
installed or upgraded before doing so, and reading any warnings about
suggested or core updates. Use `Freshen -m [<options>] [<list>]` to
display the list of updates and then prompt on whether to install them.

In shallow mode, core packages will only appear if they are requested
specifically or require an upgrade in order to install a program that
was requested. In the default, deep mode, they may appear at any time.

When one of these packages appears, consider whether the upgrade is
necessary; if so, it is recommended that these packages be upgraded
individually and manually, making a backup of the working version first
using CreatePackage and keeping track of what happens during the
install.

It is also recommended that you make sure you are running the very
latest versions of Scripts and Compile when upgrading these. You
may upgrade these tools with `InstallPackage Scripts` and
`InstallPackage Compile`.

If you decide not to update the core programs, use the --skip-core
option and they will be excluded from the generated updates list. This
will be safe unless the update was a genuine requirement for another
program you are upgrading, which is a relatively rare case, and which
is always fixable.

Core packages about which care should be taken include:""")
        sys.stdout.write(' ' + '\n '.join(self.corePrograms) + '\n')


def reportBug(exc_info):
    import traceback
    import re
    ex_type, ex_obj, ex_tb = exc_info
    Log_Error("ERROR: %s.%s: %s" %
              (ex_type.__module__, ex_type.__name__, ex_obj), 'Freshen')
    sys.stderr.write('\n')
    traceback.print_exception(ex_type, ex_obj, ex_tb)
    sys.stderr.write('\n')
    sys.stderr.write('Freshen %(major)s.%(minor)s.%(revision)s%(prerelease)s'
                        % (Freshen.version))
    sys.stderr.write(' on python ' +
                        '.'.join(map(str, sys.version_info)) + '\n')
    compileVersion = 'unknown'
    scriptsVersion = 'unknown'
    try:
        compileVersion = re.search('Compile/([^/]+)/',
                                os.popen('which Compile').read()).groups()[0]
        scriptsVersion = re.search('Scripts/([^/]+)/',
                                os.popen('which UseFlags').read()).groups()[0]
    except:
        pass
    sys.stderr.write('with Scripts %s and Compile %s\n\n' %
        (scriptsVersion, compileVersion))
    sys.stderr.write('arguments: %r\n'%(sys.argv))
    sys.stderr.write(Screen.colours['red'])
    sys.stderr.write("""
*** Freshen has encountered an internal error. Please send this report to
    gobolinux-users@lists.gobolinux.org with a description of what you were
    doing when the error occurred.
""")
    sys.stderr.write(Screen.colours['normal'])
    exit(2)


def go():
    try:
        goboPrograms = getGoboVariable('goboPrograms')
        rv = list(Freshen.requiredVersions.items())
        for (prog, ver) in Freshen.requiredVersions.items():
            cur = os.readlink(goboPrograms + '/' + prog + '/Current')
            if 'svn' not in cur.lower() and \
                GuessLatest([cur, ver]) != cur:
                Log_Error("requires %s >= %s"%(prog, ver), 'Freshen')
                exit(1)
        ui = FreshenUI()
        # Execute the defined action
        if ui.args.noCache:
            Freshen.clearCache()
        ui.args.action()
        exit(0)
    except KeyboardInterrupt:
        pass
    except SystemExit:
        pass
    except IOError:
        exc_type, exc_obj, exc_tb = sys.exc_info()
        import errno
        if exc_obj.errno in (errno.EINVAL, errno.EPIPE):
            sys.stderr.write("Freshen: broken pipe")
        else:
            reportBug(sys.exc_info())
    except BaseException:
        reportBug(sys.exc_info())
    finally: # Clear title on exit
        sys.stderr.write("\033]2;\007")
